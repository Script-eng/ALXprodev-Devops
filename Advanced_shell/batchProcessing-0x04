#!/bin/bash

# A list of Pokémon to fetch
pokemons=("Bulbasaur" "Ivysaur" "Venusaur" "Charmander" "Charmeleon")
output_dir="pokemon_data_parallel"
mkdir -p "$output_dir"

# --- Array to hold the PIDs of our background jobs ---
pids=()

# --- Define a cleanup function ---
# This function will be called by our trap when the script is interrupted.
cleanup() {
    echo -e "\nCaught signal... Cleaning up background jobs."
    # Loop through the array of PIDs and kill each one
    for pid in "${pids[@]}"; do
        # The 'kill' command sends a termination signal to the process
        kill "$pid" 2>/dev/null
    done
    echo "Cleanup complete. Exiting."
    exit 1
}

# --- Set the trap ---
# This tells the script: "If you receive an INT (Ctrl+C) or TERM signal,
# run the 'cleanup' function instead of just exiting."
trap cleanup INT TERM

# --- Define a function to fetch data for a single Pokémon ---
fetch_pokemon() {
    local pokemon_name=$1
    local lower_name=$(echo "$pokemon_name" | tr '[:upper:]' '[:lower:]')
    local output_file="$output_dir/$lower_name.json"

    echo "INFO: Starting fetch for $lower_name..."
    if curl -fs "https://pokeapi.co/api/v2/pokemon/$lower_name" -o "$output_file"; then
        echo "SUCCESS: Saved data for $lower_name ✅"
    else
        echo "ERROR: Failed to fetch data for $lower_name ❌"
        rm -f "$output_file"
    fi
}

# --- Main script execution ---
for pokemon in "${pokemons[@]}"
do
    # Launch the fetch function in the background
    fetch_pokemon "$pokemon" &
    # Store the PID of the background process in our array
    pids+=($!)
done

# Use 'wait' to pause until all background jobs finish normally
echo "--------------------------------------------------"
echo "All fetch jobs launched. Waiting for them to complete..."
wait
echo "All Pokémon data has been fetched successfully."
echo "--------------------------------------------------"

# You can optionally add a final check here
echo "Final contents of $output_dir:"
ls -l "$output_dir"